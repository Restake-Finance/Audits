# Restake Finance Audits

Our audit with Open Zeppelin has been completed. We audited the core liquid restaking contracts that are compatible with all LSDs, including rebasing and value-accruing tokens. We are now ready to execute on partnerships and integrations. 

Below is our in-depth analysis of the OpenZeppelin report, including comments and how we have resolved various challenges that are essential to liquid restaking infrastructures. 

Please find below an analysis of how we have resolved the major points brought up by OpenZeppelin. 

[Full report](https://github.com/Restake-Finance/Audits/blob/main/Restake%20OZ%20Final%20Report.pdf)

## C-01 Attacker Can Downscale All Protocol Shares by 18 Decimals

### Background
Because of the rebasing nature of stETH, keeping track of new units being created (rewards) or taken out of circulation (in case of penalties) is easiest if we manage the pool as a vault, similar to ERC4626 vaults. That is: every depositor gets shares of this pool in return for the stETH amount they deposit. So if there are 100 stETHs in the pool, and 100 existing shares, someone depositing 1 stETH would also get 1 share resulting in a total of 101 stETH and 101 shares. In time, when rewards are added by stETH rebasing, it could lead to for example 105 stETH and 101 shares, with each share having 1.0396039604 stETH.

We hide these shares behind the scenes with our own rebasing functionality for rstETH, keeping 1 rstETH = 1 stETH. After our rebasing, everyone would have 1.0396039604 times their last rstETH balance (a slight increase, representing the yield generated by Lido).
	
### Issue Summary
The issue with this was also found in the implementation of ERC4626 vaults: anyone can just send assets to the pool (vault) and modify the share per asset price. Usually that is not a problem, because anything sent to the pool is divided between holders of the pool token. The issue happens when the pool is completely empty, and the first depositor deposits just a tiny bit of asset (1 wei) and gets a tiny bit of pool token (share) in return.

Solidity only supports integer numbers, so to emulate subunits, we inflate a normal unit of token by 10 to the power of 18. Which is a HUGE number. ETH works the same way: each unit of ETH has 10^18 wei. (Bitcoin is the same, each bitcoin has 100m satoshis).

Back to the first user with the empty pool that deposited 1 wei and got 0.000000000000000001 of pool token. The share price is still 1to1 at this point. Now this first user, manually sends 1 whole stETH to the pool: now pool total stETH is 1.000000000000000001 stETH and total shares existing 0.000000000000000001 pool tokens, making the price of the pool token a HUGE number: ~10^36 -- that means, anyone depositing less than 10stETH will get 0 shares and the first user is still holding 100% of the shares (0.000000000000000001 total shares). Even if a new user deposits 15 stETH, they only receive 1 subunit of share: 0.000000000000000001, making the total shares 0.000000000000000002. So the first user still has 50% of the shares: 50% of the total of 16 stETH.

This happens basically because the lowest subunit we can count on is 0.000000000000000001 and no lower. Anything lower is rounded down to 0 because everything is integer.


### Resolving the issue
The issue has been rendered unexploitable in even the most extreme circumstances. As explained in the following paragraphs, there isn’t even a possibility of an exploit unless we consider impossibly large amounts of ETH going towards the attack.

Our fix for the issue was to introduce a sacrificial position, that is a prerequisite at deployment. This means that in order to deploy the system, which will only be done by Restake Finance, there HAS to be an initial position such that the pools will never be empty. 

To test the effectiveness of the fixes and the potential precision loss in practice, we have ran a test that:
1. Initializes the protocol with a 0.01 ETH position - essentially a little over $25 (at the time of writing) added to the cost of deployment
2. Simulate an attacker coming in and attempting to exploit the issue highlighted in the report
   
    a. Deposit
   
    b. Get shares
   
    c. Burn almost all shares until they only have 1 share left
   
4. Send 2 TRILLION ETH to the contract
5. A second user comes in and deposits 1 ETH, and gets over 0.99 rstETH (0.9998 rstETH)

What this means is that even after sending 2 trillion ETH to try and exploit this issue, even though you generate some precision loss, it doesn’t even begin to impact good faith users significantly. 

Not only the attacker needs 2 trillion of ETH to generate losses of MAXIMUM 0.0001 ETH, that ETH is also lost by the attacker. This happens because during step 2.c) - when they burn the shares, they essentially donate it to the existing shares. And the only existing shares at that point would be those that the deployer initialized with, that are sent to a burn address.

As such, this attack becomes IMPOSSIBLE if the pool has even 0.00001 existing total shares. To create a price greater than 10^18 that causes this issue, an attacker would need to deposit at least 10^31 units of stETH, meaning 10,000,000,000,000 stETH, which obviously does not even exist. EVEN if it did, the attacker would lose a big portion of it to the existing pool token holder which we call a sacrificial position of 0.00001 stETH worth, which is deposited on deploy, and the position owner change to 0x1 address so no one can ever reduce the total shares below 0.00001.

For this small "sacrificial position" mitigation strategy, we were inspired by OpenZeppelin's own erc4626 implementation where they create a virtual position. Our position is a normal position that is transferred to 0x1 which is a reserved address in Ethereum and is controlled by no one.

## H-01 Attacker Can DoS Withdrawals
### Background
EigenLayer's withdrawals are not instant and are a multistep process. Users need to signal a withdrawal and after some time they can come and claim their stETH (or other assets in the future). From the point of view of EigenLayer, Restake Finance is just a normal user. This gave us 2 options for our UX: 

a. let our users each initiate an EigenLayer withdrawal paying all the gas of calling their contract, and then moving the funds out, and claiming the assets after a week or so.

b. batch our users' withdrawals together and initiate withdrawals on behalf of all of them once in a while (once a day let's say).

We chose option (b) because it's much more gas efficient for our users. Instead of MANY users paying gas for the same operation over and over, we batch them together, and just once call EigenLayer’s contracts for withdrawal, and then only once we move the funds from EigenLayer to our contracts. After that each user can come and claim their tokens separately from our contract.


### Issue Summary
The downside of (b) is that Restake Finance has to pay some gas to iterate through our users in queue to and mark those positions as being processed etc. That iteration opens us to a DoS situation where many users can come in the queue, making the iteration process lengthier and therefore more expensive for the Restake Finance StrategyManager role.

We were ok with this trade off - and adopted it as a DESIGN DECISION - because even with this DoS potential, the cost of entering the withdrawal queue is much higher than the cost of iterating through it (almost an order of magnitude higher), making it prohibitive to attack, and much cheaper to defend.

### Resolving the issue
We therefore acknowledged the issue flagged by Open Zeppelin - however, we plan to implement a minimum withdrawal amount, as recommended by OpenZeppelin, to further increase the capital requirement for this attack. There is also an added protection, which would make an attack even more expensive and complicated. This involves successive withdrawals from the same address getting added to the same position in the queue. Meaning that an attacker would have to use different addresses, and therefore pay for ETH and token transfers for each, and then trigger transactions manually or - even worse from a cost perspective - deploy contracts for each and batch the transactions.

As a backup plan, we have the capability of upgrading the contracts in the future, allowing us to implement further defenses such as small withdrawal fees that will make the attack completely futile. But for now, we want the best UX for our users and lowest cost for withdrawals.
